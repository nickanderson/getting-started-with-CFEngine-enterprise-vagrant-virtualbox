body common control
{
  bundlesequence => {
                      "settings",
                      "desired_packages",
                      "ensure_git_user",
                      "ensure_ssh_key_config",
                      # "masterfiles_gitified",
                    };
  inputs => { "/var/cfengine/share/NovaBase/libraries/cfengine_stdlib.cf" };

}

bundle agent settings
{
  vars:
      "git_user"
        string => "git";

      "git_user_home"
        string => "/home/$(git_user)";

      "git_user_home_overlay"
        string => "/vagrant/resources/overlay_git_user_home";

      "git_user_ssh_dir"
        string => "$(git_user_home)/.ssh";

      "git_user_authorized_keys"
        string => "$(git_user_ssh_dir)/authorized_keys";

      "git_user_password_hash"
        string => "$1$MkR4OdY0$E9RYqJuHhD15Jv8IF6jFF.",
        comment => "Git user password hash for password 'git'";
 
      "masterfiles"
        string => "/var/cfengine/masterfiles";

      "masterfiles_overlay"
        string  => "/vagrant/resources/overlay_var_cfengine/masterfiles",
        comment => "These files contain customizations that are supposed to sit
                    on top fo the default masterfiles. They are recursively
                    copied over the top of $(masterfiles) after masterfiles is
                    populated with the defaults";

      "masterfiles_tmp"
        string  => "/tmp/masterfiles",
        comment => "We need a temporary location where we can do initial
                    construction of the masterfiles repository.";

      "masterfiles_base"
        string  => "/var/cfengine/share/NovaBase",
        comment => "Default polciy";

      "masterfiles_bare_git"
        string  => "$(git_user_home)/masterfiles.git",
        comment => "We need a central git repository for a policy writer to
                    clone, modify and push changes to and where the policy
                    server can source its masterfiles from.";

      "mission_portal_priv_ssh_key"
        string => "/vagrant/policyserver.id_rsa";

      "mission_portal_priv_ssh_key"
        string  => "/vagrant/policyserver.id_rsa",
        comment => "This ssh key is neeed for mission portal authentication to
                    the git repository";

      "desired_packages"
        slist => { "vim-enhanced", "git", "emacs-nox" };
}

bundle agent masterfiles_gitified
{
  classes:
      "masterfiles_bare_git_exists" expression => fileexists("$(settings.masterfiles_bare_git)/HEAD");
      "masterfiles_tmp_exists" expression => fileexists("$(settings.masterfiles_tmp)");

  files:
      "$(settings.masterfiles_bare_git)/."
        create => "true",
        perms  => og("$(settings.git_user)", "$(settings.git_user)");

    masterfiles_tmp_repaired::
      "$(settings.masterfiles_tmp)/."
        handle => "populate_masterfiles_tmp_with_masterfiles_base",
        depth_search => recurse("inf"),
        copy_from => local_cp("$(settings.masterfiles_base)/.");

      "$(settings.masterfiles_tmp)/."
        handle => "overlay_default_masterfiles",
        depth_search => recurse("inf"),
        depends_on => { "populate_masterfiles_tmp_with_masterfiles_base" }, 
        classes => classes_generic("overlay_default_masterfiles"),
        copy_from => local_cp("$(settings.masterfiles_overlay)/.");

  commands:
    !masterfiles_bare_git_exists::
      "/usr/bin/git"
        args => "init --bare",
        contain => setuidgid_dir("$(settings.git_user)", "$(settings.git_user)", "$(settings.masterfiles_bare_git)"),
        classes => classes_generic("masterfiles_bare_git");

    masterfiles_bare_git_repaired::
      "/usr/bin/git"
        args => "clone $(settings.masterfiles_bare_git) $(settings.masterfiles_tmp)",
        classes => classes_generic("masterfiles_tmp"),
        comment => "We need a place to stage and commit the files from the
                    default policy and the custom overlay";

    git_commit_initial::
      #transform .git directory in tmp dir over to masterfiiles proper

    overlay_default_masterfiles_repaired::
      "/usr/bin/git"
        handle => "git_config_user_email",
        args => "config user.email '$(settings.git_user)@policyserver.local'",
        contain => setuidgid_dir("$(settings.git_user)", "$(settings.git_user)", "$(settings.masterfiles_tmp)");
        
      "/usr/bin/git"
        handle => "git_config_user_name",
        args => "config user.name '$(settings.git_user)'",
        contain => setuidgid_dir("$(settings.git_user)", "$(settings.git_user)", "$(settings.masterfiles_tmp)");
      
      "/usr/bin/git"
        handle => "git_config_push_default_matching",
        args => "config push.default matching",
        contain => setuidgid_dir("$(settings.git_user)", "$(settings.git_user)", "$(settings.masterfiles_tmp)");

      "/usr/bin/git"
        handle => "git_add",
        args => "add .",
        contain => setuidgid_dir("$(settings.git_user)", "$(settings.git_user)", "$(settings.masterfiles_tmp)");

      "/usr/bin/git"
        handle => "git_commit_initial",
        args => "commit -m 'initial commit'",
        depends_on => { "git_add", "git_config_push_default_matching", "git_config_user_name", "git_config_user_email" },
        contain => setuidgid_dir("$(settings.git_user)", "$(settings.git_user)", "$(settings.masterfiles_tmp)");
    
      "/usr/bin/git"
        handle => "git_push",
        args => "push origin master",
        depends_on => { "git_commit_initial" },
        contain => setuidgid_dir("$(settings.git_user)", "$(settings.git_user)", "$(settings.masterfiles_tmp)");

      # When .git exists in masterfiles proper
      #git reset hard head 
      #remove tmp masterfiles if .git directory exists in masterfiles

}

body contain setuidgid_dir(uid, gid, dir)
{
  exec_owner => "$(uid)";
  chdir => "$(dir)";
  exec_group => "$(gid)";
}

bundle agent desired_packages
{
  packages:
      "$(settings.desired_packages)"
        package_method => yum_rpm_enable_only_repo("localcache"),
        package_policy => "add";
}

bundle agent ensure_git_user
{
  classes:
    "git_user_exists" expression => userexists("$(settings.git_user)");

  commands:
    !git_user_exists::
      "/usr/sbin/useradd"
        args    => "$(settings.git_user)",
        handle  => "ensure_git_user_commands_useradd",
        comment => "We need a non root user to host the repositoriy in order to
                    be able to disable root ssh login";

  files:
      "/etc/shadow"
        edit_line => set_user_field("$(settings.git_user)", "2", "$(settings.git_user_password_hash)"),
        comment   => "Ensure the git user has a known password";
      
      "$(settings.git_user_home)/."
        copy_from    => local_cp("$(settings.git_user_home_overlay)"),
        depth_search => recurse("inf"),
        perms        => og("$(settings.git_user)", "$(settings.git_user)"),
        comment      => "Populate the git users home directory with things to make
                        editing policy more pleasent";

      "$(settings.git_user_home)"
        perms        => mog("700", "$(settings.git_user)", "$(settings.git_user)"),
        comment      => "We need to make sure the git user owns its own home directory";

}

bundle agent ensure_ssh_key_config
{
  vars:
    mission_portal_pub_ssh_key_exists:: 
      "mission_portal_pub_ssh_key"
        string => readfile("$(settings.mission_portal_priv_ssh_key).pub", "1024");

  classes:
      "mission_portal_priv_ssh_key_exists"
        expression => fileexists("$(settings.mission_portal_priv_ssh_key)"); 

      "mission_portal_pub_ssh_key_exists"
        expression => fileexists("$(settings.mission_portal_priv_ssh_key).pub"); 

  commands:
    !mission_portal_priv_ssh_key_exists::
      "/usr/bin/ssh-keygen"
        args    => "-C 'Mission Portal Git User' -N '' -f $(settings.mission_portal_priv_ssh_key)",
        comment => "Mission portal does not support using keys with passphrases
                    so we need to generate a passphraseless key to use with it.";

  files:
      "$(settings.git_user_ssh_dir)/."
        create => "true",
        perms  => mog("700", "git", "git");

      "$(settings.git_user_authorized_keys)"
        create    => "true",
        perms     => mog("600", "$(settings.git_user)", "$(settings.git_user)"),
        edit_line => append_if_no_lines("$(mission_portal_pub_ssh_key)");
}

body package_method yum_rpm_enable_only_repo(repoid)

# based on yum_rpm with addition to enable a repository for the install
# Sometimes repositories are configured but disabled by default. For example
# this pacakge_method could be used when installing a package that exists in
# the EPEL, which normally you do not want to install packages from.
{
  package_changes => "bulk";
  package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
  package_patch_list_command => "/usr/bin/yum --quiet check-update";

  package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
  package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
  package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";

  package_installed_regex => ".*";
  package_name_convention => "$(name)";

  # set it to "0" to avoid caching of list during upgrade
  package_list_update_command => "/usr/bin/yum --quiet check-update";
  package_list_update_ifelapsed => "240";

  package_patch_installed_regex => "^\s.*";
  package_patch_name_regex    => "([^.]+).*";
  package_patch_version_regex => "[^\s]\s+([^\s]+).*";
  package_patch_arch_regex    => "[^.]+\.([^\s]+).*";

  package_add_command    => "/usr/bin/yum --disablerepo=* --enablerepo=$(repoid) -y install";
  package_update_command => "/usr/bin/yum --disablerepo=* --enablerepo=$(repoid) -y update";
  package_patch_command => "/usr/bin/yum -y update";
  package_delete_command => "/bin/rpm -e --nodeps --allmatches";
  package_verify_command => "/bin/rpm -V";
}
